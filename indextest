<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daily 15 | Puzzle Game</title>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNLVGXD9M4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZNLVGXD9M4');
</script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      overflow-x: hidden;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      padding: 15px; color: white;
    }
    .container {
      text-align: center;
      max-width: 500px; width: 100%;
      display: flex; flex-direction: column; justify-content: center;
    }
    h1 { font-size: clamp(20px, 4vw, 32px); margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    
    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      background: rgba(255,255,255,0.1);
      padding: 8px;
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }
    .mode-btn {
      flex: 1;
      padding: 12px 20px;
      border: none;
      border-radius: 50px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      background: transparent;
      color: rgba(255,255,255,0.7);
      font-size: 14px;
    }
    .mode-btn.active {
      background: white;
      color: #667eea;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .mode-btn:hover:not(.active) {
      background: rgba(255,255,255,0.1);
      color: white;
    }
    
    /* Quick Play Timer */
    .timer-container {
      background: rgba(255,255,255,0.15);
      padding: 15px;
      border-radius: 15px;
      margin-bottom: 15px;
      display: none;
      backdrop-filter: blur(10px);
    }
    .timer-container.active {
      display: block;
    }
    .timer-display {
      font-size: 36px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .timer-display.warning {
      color: #ff6b6b;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .timer-label {
      font-size: 14px;
      opacity: 0.9;
    }
    
    .game-info {
      display: flex; justify-content: space-between; margin-bottom: 15px;
      font-size: clamp(14px, 3vw, 18px); font-weight: 600;
    }
    .puzzle-container {
      background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
      border-radius: 20px; padding: 15px; margin-bottom: 15px;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    .puzzle-grid {
      display: grid;
      gap: 8px;
      aspect-ratio: 1;
      width: 100%; margin: 0 auto;
      background: rgba(0,0,0,0.2); border-radius: 15px; padding: 15px;
    }
    .puzzle-grid.grid-4x4 {
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      max-width: min(350px, 70vw);
    }
    .puzzle-grid.grid-3x3 {
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      max-width: min(300px, 70vw);
    }
    .tile {
      background: linear-gradient(145deg, #ffffff, #e6e6e6);
      border: none; border-radius: 12px;
      font-size: clamp(18px, 4vw, 28px); font-weight: bold;
      color: #333; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      user-select: none; transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .tile:hover { transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0); }
    .tile.empty { background: transparent; box-shadow: none; cursor: default; pointer-events: none; }
    .tile.moveable { background: linear-gradient(145deg, #4CAF50, #45a049); color: white; }
    .controls { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px; }
    .btn {
      background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
      border: none; border-radius: 25px; padding: 10px 20px;
      font-size: clamp(12px, 2.5vw, 16px); font-weight: 600;
      color: white; cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      min-width: 80px;
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    .btn.shuffle { background: linear-gradient(145deg, #4CAF50, #45a049); }
    .btn.share { background: linear-gradient(145deg, #2196F3, #1976D2); }
    .btn.tutorial { background: linear-gradient(145deg, #9C27B0, #7B1FA2); }
    .btn.stats { background: linear-gradient(145deg, #FF9800, #F57C00); }
    .btn.quickplay { 
      background: linear-gradient(145deg, #FFD700, #FFA500);
      font-size: clamp(14px, 3vw, 18px);
      padding: 14px 28px;
      animation: glow 2s infinite;
    }
    @keyframes glow {
      0%, 100% { box-shadow: 0 4px 15px rgba(255,215,0,0.4); }
      50% { box-shadow: 0 4px 25px rgba(255,215,0,0.8); }
    }
    
    /* Live Stats Banner */
    .live-stats {
      background: rgba(255,255,255,0.1);
      padding: 10px;
      border-radius: 12px;
      margin-bottom: 15px;
      font-size: 13px;
      backdrop-filter: blur(10px);
    }
    .live-stats-item {
      display: inline-block;
      margin: 0 10px;
    }
    
    .winner-message {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #4CAF50, #45a049);
      color: white; padding: 25px; border-radius: 20px;
      font-size: clamp(18px, 4vw, 22px); font-weight: bold;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 1000; display: none; text-align: center;
      max-width: 90vw;
    }
    .overlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999; display: none;
    }
    
    /* Stats Modal Styles */
    .stats-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      z-index: 1001;
      display: none;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }
    .stats-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 24px;
      border-radius: 24px 24px 0 0;
      position: relative;
    }
    .stats-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.2s;
    }
    .stats-close:hover {
      background: rgba(255,255,255,0.3);
      transform: rotate(90deg);
    }
    .stats-content {
      padding: 24px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: linear-gradient(145deg, #f8f9fa, #e9ecef);
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      transition: transform 0.2s;
    }
    .stat-card:hover {
      transform: translateY(-4px);
    }
    .stat-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }
    .stat-value {
      font-size: 32px;
      font-weight: bold;
      color: #333;
    }
    .stat-label {
      font-size: 13px;
      color: #666;
      margin-top: 4px;
      font-weight: 600;
    }
    .stats-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }
    .stats-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }
    .stats-btn.export {
      background: linear-gradient(145deg, #2196F3, #1976D2);
      color: white;
    }
    .stats-btn.reset {
      background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
      color: white;
    }
    .stats-note {
      text-align: center;
      font-size: 12px;
      color: #666;
      background: #fff3cd;
      padding: 12px;
      border-radius: 12px;
      margin-top: 16px;
      border: 1px solid #ffc107;
    }
    .quick-stats {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }
    .quick-stats h3 {
      color: #333;
      font-size: 16px;
      margin-bottom: 12px;
    }
    .quick-stat-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #e0e0e0;
      font-size: 14px;
    }
    .quick-stat-row:last-child {
      border-bottom: none;
    }
    .quick-stat-label {
      color: #666;
    }
    .quick-stat-value {
      color: #333;
      font-weight: bold;
    }
    
    /* Leaderboard */
    .leaderboard {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }
    .leaderboard h3 {
      color: #333;
      font-size: 16px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      margin-bottom: 8px;
      background: white;
      border-radius: 8px;
      align-items: center;
    }
    .leaderboard-entry.current-user {
      background: #e3f2fd;
      border: 2px solid #2196F3;
    }
    .leaderboard-rank {
      font-weight: bold;
      color: #667eea;
      min-width: 30px;
    }
    .leaderboard-name {
      flex: 1;
      text-align: left;
      margin-left: 10px;
      color: #333;
    }
    .leaderboard-score {
      font-weight: bold;
      color: #4CAF50;
    }
    
    /* Monthly Tier Distribution Styles */
    .tier-distribution {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }
    .tier-distribution h3 {
      color: #333;
      font-size: 16px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .tier-bar {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }
    .tier-bar:last-child {
      margin-bottom: 0;
    }
    .tier-label {
      min-width: 110px;
      font-size: 13px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .tier-bar-container {
      flex: 1;
      height: 20px;
      background: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }
    .tier-bar-fill {
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 6px;
      font-size: 11px;
      font-weight: 600;
      color: white;
    }
    .tier-count {
      min-width: 20px;
      text-align: center;
      font-size: 13px;
      font-weight: bold;
      color: #333;
    }
    .tier-grandmaster { background: linear-gradient(90deg, #FFD700, #FFA500); }
    .tier-master { background: linear-gradient(90deg, #C0C0C0, #A8A8A8); }
    .tier-expert { background: linear-gradient(90deg, #CD7F32, #B87333); }
    .tier-advanced { background: linear-gradient(90deg, #667eea, #764ba2); }
    .tier-skilled { background: linear-gradient(90deg, #4CAF50, #45a049); }
    .tier-intermediate { background: linear-gradient(90deg, #2196F3, #1976D2); }
    .tier-beginner { background: linear-gradient(90deg, #FF9800, #F57C00); }
    .tier-novice { background: linear-gradient(90deg, #9E9E9E, #757575); }
    .month-badge {
      font-size: 11px;
      padding: 2px 8px;
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      border-radius: 8px;
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      text-align: right;
      line-height: 1.3;
    }
    .month-name {
      font-size: 10px;
      opacity: 0.8;
      font-weight: normal;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🧩 Daily 15 | Puzzle Game</h1>
    
    <!-- Mode Toggle -->
    <div class="mode-toggle">
      <button class="mode-btn active" onclick="switchMode('daily')">📅 Daily Puzzle</button>
      <button class="mode-btn" onclick="switchMode('quickplay')">⚡ Quick Play</button>
    </div>
    
    <!-- Timer (Quick Play only) -->
    <div class="timer-container" id="timerContainer">
      <div class="timer-display" id="timerDisplay">60</div>
      <div class="timer-label">seconds remaining</div>
    </div>
    

    
    <div class="game-info">
      <div>
        <div style="font-size: 14px; opacity: 0.9;" id="puzzleLabel">Daily Puzzle #<span id="puzzleNumber"></span></div>
        <div>Moves: <span id="moveCounter">0</span></div>
      </div>
      <div style="text-align: right;">
        <div style="font-size: 14px; opacity: 0.9;" id="dateDisplay"></div>
        <div id="status">Ready to play!</div>
      </div>
    </div>
    <div class="puzzle-container">
      <div class="puzzle-grid grid-4x4" id="puzzleGrid"></div>
    </div>
    <div class="controls">
      <button class="btn shuffle" onclick="loadDailyPuzzle()" id="dailyBtn">Today's Puzzle</button>
      <button class="btn quickplay" onclick="startQuickPlay()" id="quickplayBtn" style="display: none;">⚡ START (60s)</button>
      <button class="btn" onclick="resetPuzzle()">Reset</button>
      <button class="btn stats" onclick="openStatsModal()">📊 Stats</button>
      <button class="btn tutorial" onclick="window.open('./tutorial.html','_blank')">How to Play</button>
      <button class="btn share" onclick="shareResult()" id="shareBtn" style="display: none;">Share Result</button>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="winner-message" id="winnerMessage">
    🎉 Congratulations! 🎉<br>
    <span id="completionText">You solved today's puzzle!</span><br>
    <small>Click anywhere to continue</small>
  </div>

  <!-- Stats Modal -->
  <div class="stats-modal" id="statsModal">
    <div class="stats-header">
      <button class="stats-close" onclick="closeStatsModal()">×</button>
      <h2 style="font-size: 24px; margin-bottom: 4px;">📊 Your Statistics</h2>
      <p style="font-size: 14px; opacity: 0.9;">Track your Daily15 progress</p>
    </div>
    <div class="stats-content">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-icon">📅</div>
          <div class="stat-value" id="statGamesPlayed">0</div>
          <div class="stat-label">Games Played</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">⚡</div>
          <div class="stat-value" id="statBestPerformance">-</div>
          <div class="stat-label">Best Performance</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">🔥</div>
          <div class="stat-value" id="statCurrentStreak">0</div>
          <div class="stat-label">Current Streak</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">🏆</div>
          <div class="stat-value" id="statMaxStreak">0</div>
          <div class="stat-label">Best Streak</div>
        </div>
      </div>

      <!-- Quick Play Stats -->
      <div class="quick-stats" id="quickplayStats">
        <h3>⚡ Quick Play Stats</h3>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Games Played:</span>
          <span class="quick-stat-value" id="qpGamesPlayed">0</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Games Won:</span>
          <span class="quick-stat-value" id="qpGamesWon">0</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Best Time:</span>
          <span class="quick-stat-value" id="qpBestTime">-</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Avg Moves:</span>
          <span class="quick-stat-value" id="qpAvgMoves">-</span>
        </div>
      </div>

      <!-- Hourly Leaderboard -->
      <div class="leaderboard" id="leaderboardSection">
        <h3>
          <span>🏆 This Hour's Leaders</span>
          <span style="font-size: 11px; opacity: 0.7;">Resets :00</span>
        </h3>
        <div id="leaderboardEntries">
          <div style="text-align: center; padding: 20px; color: #999;">
            Complete a Quick Play to join!
          </div>
        </div>
      </div>

      <!-- Monthly Tier Distribution -->
      <div class="tier-distribution" id="tierDistribution">
        <h3>
          <span>This Month's Performance</span>
          <span class="month-badge" id="monthTotal">
            <span class="month-name" id="monthName">October 2025</span>
            <span id="solveCount">0 solves</span>
          </span>
        </h3>
        <div class="tier-bar">
          <div class="tier-label">🥇 Grandmaster</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-grandmaster" id="bar-grandmaster" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-grandmaster">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🥈 Master</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-master" id="bar-master" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-master">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🥉 Expert</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-expert" id="bar-expert" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-expert">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">💎 Advanced</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-advanced" id="bar-advanced" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-advanced">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">⭐ Skilled</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-skilled" id="bar-skilled" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-skilled">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🎯 Intermediate</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-intermediate" id="bar-intermediate" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-intermediate">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">📚 Beginner</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-beginner" id="bar-beginner" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-beginner">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🌱 Novice</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-novice" id="bar-novice" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-novice">0</div>
        </div>
      </div>

      <div class="quick-stats">
        <h3>My Stats</h3>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Total Wins:</span>
          <span class="quick-stat-value" id="statTotalWins">0</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Average Moves:</span>
          <span class="quick-stat-value" id="statAvgMoves">0</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Best Moves:</span>
          <span class="quick-stat-value" id="statBestMoves">-</span>
        </div>
      </div>

      <div class="stats-actions">
        <button class="stats-btn export" onclick="exportStats()">💾 Backup</button>
        <button class="stats-btn reset" onclick="resetStats()">🗑️ Reset</button>
      </div>

      <div class="stats-note">
        📱 Stats are saved locally on this device
      </div>
    </div>
  </div>

  <script>
    // Game State
    let currentMode = 'daily'; // 'daily' or 'quickplay'
    let quickPlayTimer = null;
    let quickPlayTimeLeft = 60;
    let quickPlayActive = false;
    
    // Stats Manager with Monthly Tracking
    class Daily15StatsManager {
      constructor() {
        this.storageKey = 'daily15_game_stats';
        this.monthlyTiersKey = 'daily15_monthly_tiers';
        this.quickPlayKey = 'daily15_quickplay_stats';
        this.leaderboardKey = 'daily15_leaderboard';
        this.loadStats();
        this.loadMonthlyTiers();
        this.loadQuickPlayStats();
        this.loadLeaderboard();
      }

      loadStats() {
        const stored = localStorage.getItem(this.storageKey);
        if (stored) {
          this.stats = JSON.parse(stored);
        } else {
          this.stats = {
            gamesPlayed: 0,
            gamesWon: 0,
            currentStreak: 0,
            maxStreak: 0,
            lastPlayedDate: null,
            puzzleHistory: {}
          };
        }
      }

      saveStats() {
        localStorage.setItem(this.storageKey, JSON.stringify(this.stats));
      }

      loadQuickPlayStats() {
        const stored = localStorage.getItem(this.quickPlayKey);
        if (stored) {
          this.quickPlayStats = JSON.parse(stored);
        } else {
          this.quickPlayStats = {
            gamesPlayed: 0,
            gamesWon: 0,
            bestTime: null,
            totalMoves: 0,
            gameHistory: []
          };
        }
      }

      saveQuickPlayStats() {
        localStorage.setItem(this.quickPlayKey, JSON.stringify(this.quickPlayStats));
      }

      recordQuickPlayGame(won, moves, timeUsed) {
        this.quickPlayStats.gamesPlayed++;
        if (won) {
          this.quickPlayStats.gamesWon++;
          this.quickPlayStats.totalMoves += moves;
          
          if (!this.quickPlayStats.bestTime || timeUsed < this.quickPlayStats.bestTime) {
            this.quickPlayStats.bestTime = timeUsed;
          }
          
          this.quickPlayStats.gameHistory.push({
            moves: moves,
            time: timeUsed,
            timestamp: Date.now()
          });
          
          // Add to leaderboard
          this.addToLeaderboard(moves, timeUsed);
        }
        this.saveQuickPlayStats();
      }

      getQuickPlayStats() {
        const avgMoves = this.quickPlayStats.gamesWon > 0 
          ? Math.round(this.quickPlayStats.totalMoves / this.quickPlayStats.gamesWon)
          : 0;
        
        return {
          gamesPlayed: this.quickPlayStats.gamesPlayed,
          gamesWon: this.quickPlayStats.gamesWon,
          bestTime: this.quickPlayStats.bestTime,
          avgMoves: avgMoves
        };
      }

      loadLeaderboard() {
        const stored = localStorage.getItem(this.leaderboardKey);
        const currentHour = this.getCurrentHour();
        
        if (stored) {
          const data = JSON.parse(stored);
          if (data.hour === currentHour) {
            this.leaderboard = data;
          } else {
            this.leaderboard = this.initializeLeaderboard(currentHour);
          }
        } else {
          this.leaderboard = this.initializeLeaderboard(currentHour);
        }
      }

      getCurrentHour() {
        const now = new Date();
        return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}-${String(now.getHours()).padStart(2, '0')}`;
      }

      initializeLeaderboard(hour) {
        return {
          hour: hour,
          entries: []
        };
      }

      addToLeaderboard(moves, time) {
        const currentHour = this.getCurrentHour();
        if (this.leaderboard.hour !== currentHour) {
          this.leaderboard = this.initializeLeaderboard(currentHour);
        }

        const username = this.getUsername();
        const score = time; // Lower is better
        
        this.leaderboard.entries.push({
          username: username,
          moves: moves,
          time: time,
          timestamp: Date.now()
        });
        
        // Sort by time (fastest first), keep top 10
        this.leaderboard.entries.sort((a, b) => a.time - b.time);
        this.leaderboard.entries = this.leaderboard.entries.slice(0, 10);
        
        this.saveLeaderboard();
      }

      getUsername() {
        let username = localStorage.getItem('daily15_username');
        if (!username) {
          username = 'Player' + Math.floor(Math.random() * 10000);
          localStorage.setItem('daily15_username', username);
        }
        return username;
      }

      saveLeaderboard() {
        localStorage.setItem(this.leaderboardKey, JSON.stringify(this.leaderboard));
      }

      getLeaderboard() {
        const currentHour = this.getCurrentHour();
        if (this.leaderboard.hour !== currentHour) {
          this.leaderboard = this.initializeLeaderboard(currentHour);
          this.saveLeaderboard();
        }
        return this.leaderboard.entries;
      }

      loadMonthlyTiers() {
        const stored = localStorage.getItem(this.monthlyTiersKey);
        const currentMonth = this.getCurrentMonth();
        
        if (stored) {
          const data = JSON.parse(stored);
          if (data.month === currentMonth) {
            this.monthlyTiers = data;
          } else {
            this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
          }
        } else {
          this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
        }
      }

      getCurrentMonth() {
        const now = new Date();
        return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
      }

      initializeMonthlyTiers(month) {
        return {
          month: month,
          counts: {
            'Grandmaster': 0,
            'Master': 0,
            'Expert': 0,
            'Advanced': 0,
            'Skilled': 0,
            'Intermediate': 0,
            'Beginner': 0,
            'Novice': 0
          }
        };
      }

      saveMonthlyTiers() {
        localStorage.setItem(this.monthlyTiersKey, JSON.stringify(this.monthlyTiers));
      }

      recordGame(puzzleId, won, moves) {
        const today = new Date().toISOString().split('T')[0];
        
        this.stats.gamesPlayed++;
        if (won) this.stats.gamesWon++;

        if (won) {
          const alreadyWonToday = Object.values(this.stats.puzzleHistory).some(
            game => game.date === today && game.won
          );
          
          if (!alreadyWonToday) {
            if (this.isConsecutiveDay(this.stats.lastPlayedDate, today)) {
              this.stats.currentStreak++;
            } else if (this.stats.lastPlayedDate === today) {
              // Already played today, don't change streak
            } else {
              this.stats.currentStreak = 1;
            }
            this.stats.maxStreak = Math.max(this.stats.maxStreak, this.stats.currentStreak);
            this.stats.lastPlayedDate = today;
          }
        } else {
          this.stats.currentStreak = 0;
          this.stats.lastPlayedDate = today;
        }

        this.stats.puzzleHistory[puzzleId] = {
          date: today,
          won: won,
          moves: moves,
          timestamp: Date.now()
        };

        this.saveStats();
      }

      recordTier(tier) {
        const currentMonth = this.getCurrentMonth();
        if (this.monthlyTiers.month !== currentMonth) {
          this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
        }
        this.monthlyTiers.counts[tier]++;
        this.saveMonthlyTiers();
      }

      getMonthlyTiers() {
        const currentMonth = this.getCurrentMonth();
        if (this.monthlyTiers.month !== currentMonth) {
          this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
          this.saveMonthlyTiers();
        }
        return this.monthlyTiers.counts;
      }

      isConsecutiveDay(lastDate, currentDate) {
        if (!lastDate) return false;
        const last = new Date(lastDate);
        const current = new Date(currentDate);
        const diffTime = current - last;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);
        return diffDays === 1;
      }

      getStats() {
        const winningGames = Object.values(this.stats.puzzleHistory).filter(g => g.won);
        const avgMoves = winningGames.length > 0 
          ? Math.round(winningGames.reduce((sum, g) => sum + g.moves, 0) / winningGames.length)
          : 0;
        const bestMoves = winningGames.length > 0
          ? Math.min(...winningGames.map(g => g.moves))
          : null;

        return {
          gamesPlayed: this.stats.gamesPlayed,
          gamesWon: this.stats.gamesWon,
          winRate: this.stats.gamesPlayed > 0 
            ? Math.round((this.stats.gamesWon / this.stats.gamesPlayed) * 100) 
            : 0,
          currentStreak: this.stats.currentStreak,
          maxStreak: this.stats.maxStreak,
          avgMoves: avgMoves,
          bestMoves: bestMoves
        };
      }

      hasPlayedPuzzle(puzzleId) {
        return this.stats.puzzleHistory.hasOwnProperty(puzzleId);
      }

      exportStats() {
        return JSON.stringify({
          stats: this.stats,
          quickPlay: this.quickPlayStats,
          monthlyTiers: this.monthlyTiers
        });
      }

      resetStats() {
        localStorage.removeItem(this.storageKey);
        localStorage.removeItem(this.monthlyTiersKey);
        localStorage.removeItem(this.quickPlayKey);
        localStorage.removeItem(this.leaderboardKey);
        this.loadStats();
        this.loadMonthlyTiers();
        this.loadQuickPlayStats();
        this.loadLeaderboard();
      }
    }

    const statsManager = new Daily15StatsManager();

    // Original Game Code
    let puzzle = [];
    let emptyIndex = 15;
    let moves = 0;
    let dailyPuzzleLoaded = false;
    let startTime = null;
    let completionTime = null;
    let gridSize = 4; // 4x4 for daily, 3x3 for quickplay

    function getTodaysSeed() {
        const today = new Date();
        return today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
    }

    function getPuzzleNumber() {
        const today = new Date();
        const epoch = new Date('2025-09-20');
        const diffTime = Math.abs(today - epoch);
        return Math.floor(diffTime / (1000 * 60 * 60 * 24)) + 1;
    }

    class SeededRandom {
        constructor(seed) {
            this.seed = seed % 2147483647;
            if (this.seed <= 0) this.seed += 2147483646;
        }
        next() {
            this.seed = this.seed * 16807 % 2147483647;
            return (this.seed - 1) / 2147483646;
        }
    }

    // Mode Switching
    function switchMode(mode) {
        currentMode = mode;
        const buttons = document.querySelectorAll('.mode-btn');
        buttons.forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        if (mode === 'daily') {
            document.getElementById('timerContainer').classList.remove('active');
            document.getElementById('dailyBtn').style.display = 'inline-block';
            document.getElementById('quickplayBtn').style.display = 'none';
            document.getElementById('puzzleLabel').innerHTML = 'Daily Puzzle #<span id="puzzleNumber"></span>';
            gridSize = 4;
            loadDailyPuzzle();
        } else {
            document.getElementById('timerContainer').classList.add('active');
            document.getElementById('dailyBtn').style.display = 'none';
            document.getElementById('quickplayBtn').style.display = 'inline-block';
            document.getElementById('puzzleLabel').textContent = 'Quick Play (3x3)';
            gridSize = 3;
            initQuickPlayPuzzle();
        }
    }

    // Quick Play Functions
    function startQuickPlay() {
        quickPlayActive = true;
        quickPlayTimeLeft = 60;
        startTime = Date.now();
        updateTimer();
        startQuickPlayTimer();
        generateQuickPlayPuzzle();
        document.getElementById('quickplayBtn').disabled = true;
        updateStatus("GO! Solve it fast! ⚡");
    }

    function startQuickPlayTimer() {
        if (quickPlayTimer) clearInterval(quickPlayTimer);
        
        quickPlayTimer = setInterval(() => {
            quickPlayTimeLeft--;
            updateTimer();
            
            if (quickPlayTimeLeft <= 10) {
                document.getElementById('timerDisplay').classList.add('warning');
            }
            
            if (quickPlayTimeLeft <= 0) {
                endQuickPlay(false);
            }
        }, 1000);
    }

    function updateTimer() {
        document.getElementById('timerDisplay').textContent = quickPlayTimeLeft;
    }

    function endQuickPlay(won) {
        clearInterval(quickPlayTimer);
        quickPlayActive = false;
        document.getElementById('quickplayBtn').disabled = false;
        document.getElementById('timerDisplay').classList.remove('warning');
        
        const timeUsed = 60 - quickPlayTimeLeft;
        statsManager.recordQuickPlayGame(won, moves, timeUsed);
        
        if (won) {
            showQuickPlayWinMessage(timeUsed);
        } else {
            updateStatus("Time's up! Try again! 🔄");
            setTimeout(() => {
                if (confirm("Time's up! Want to try again?")) {
                    startQuickPlay();
                }
            }, 500);
        }
    }

    function generateQuickPlayPuzzle() {
        initPuzzle();
        gridSize = 3;
        puzzle = [];
        for (let i = 1; i <= 8; i++) puzzle.push(i);
        puzzle.push(null);
        emptyIndex = 8;
        
        // Generate solvable 3x3 puzzle with fewer scrambles (easier)
        const rng = new SeededRandom(Date.now());
        for (let i = 0; i < 50; i++) {  // Only 50 moves for easier puzzle
            const validMoves = [];
            for (let j = 0; j < 9; j++) if (canMove(j)) validMoves.push(j);
            if (validMoves.length > 0) {
                const randomMove = validMoves[Math.floor(rng.next() * validMoves.length)];
                puzzle[emptyIndex] = puzzle[randomMove];
                puzzle[randomMove] = null;
                emptyIndex = randomMove;
            }
        }
        
        moves = 0;
        dailyPuzzleLoaded = true;
        const grid = document.getElementById('puzzleGrid');
        grid.className = 'puzzle-grid grid-3x3';
        createGrid();
        updateDisplay();
    }

    function initQuickPlayPuzzle() {
        initPuzzle();
        gridSize = 3;
        puzzle = [];
        for (let i = 1; i <= 8; i++) puzzle.push(i);
        puzzle.push(null);
        emptyIndex = 8;
        moves = 0;
        dailyPuzzleLoaded = false;
        const grid = document.getElementById('puzzleGrid');
        grid.className = 'puzzle-grid grid-3x3';
        createGrid();
        updateDisplay();
        updateStatus("Click START to begin! ⚡");
    }

    function showQuickPlayWinMessage(timeUsed) {
        dailyPuzzleLoaded = false;
        
        let award = '';
        if (timeUsed <= 15) {
            award = '⚡ SPEED DEMON! ⚡';
        } else if (timeUsed <= 30) {
            award = '🏆 LIGHTNING CHAMPION! 🏆';
        } else if (timeUsed <= 45) {
            award = '⭐ QUICK SOLVER! ⭐';
        } else {
            award = '🎯 PUZZLE MASTER! 🎯';
        }

        updateStatus(`Solved in ${timeUsed}s! ${award}`);

        let completionHTML = `
            <div style="color: #FFFFFF; font-size: 24px; margin-bottom: 10px;">
                ${award}
            </div>
            <div style="font-size: 18px; margin-bottom: 10px;">
                ⏱️ ${timeUsed} seconds<br>
                📊 ${moves} moves
            </div>
            <div style="font-size: 14px; margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                <button onclick="startQuickPlay(); document.getElementById('overlay').style.display='none'; document.getElementById('winnerMessage').style.display='none';" style="background: white; color: #667eea; border: none; padding: 10px 20px; border-radius: 20px; font-weight: bold; cursor: pointer; margin-right: 10px;">
                    🔄 Play Again
                </button>
                <button onclick="document.getElementById('overlay').style.display='none'; document.getElementById('winnerMessage').style.display='none'; openStatsModal();" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: bold; cursor: pointer;">
                    📊 View Stats
                </button>
            </div>`;

        document.getElementById('completionText').innerHTML = completionHTML;
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('winnerMessage').style.display = 'block';
    }

// Original functions adapted for both modes
    function loadProgress() {
        if (currentMode !== 'daily') return false;
        const today = getTodaysSeed();
        const saved = localStorage.getItem(`puzzle_${today}`);
        if (saved) {
            const data = JSON.parse(saved);
            puzzle = data.puzzle;
            emptyIndex = data.emptyIndex;
            moves = data.moves;
            dailyPuzzleLoaded = true;
            gridSize = 4;

            if (data.completed) {
                completionTime = data.completionTime;
                document.getElementById('shareBtn').style.display = 'inline-block';
                updateStatus(`Completed in ${moves} moves!`);
            } else {
                startTime = data.startTime || Date.now();
                updateStatus("Continue today's puzzle!");
            }
            return true;
        }
        return false;
    }

    function saveProgress(completed = false) {
        if (currentMode !== 'daily') return;
        const today = getTodaysSeed();
        localStorage.setItem(`puzzle_${today}`, JSON.stringify({
            puzzle, emptyIndex, moves,
            startTime, completed,
            completionTime: completed ? Date.now() : null
        }));
    }

    function initPuzzle() {
        puzzle = [];
        const size = gridSize * gridSize;
        for (let i = 1; i < size; i++) puzzle.push(i);
        puzzle.push(null);
        emptyIndex = size - 1;
        moves = 0;
        dailyPuzzleLoaded = false;
        startTime = null;
        completionTime = null;
        updateDisplay();
        updateDateDisplay();
        document.getElementById('shareBtn').style.display = 'none';
    }

    function updateDateDisplay() {
        const today = new Date();
        const options = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
        document.getElementById('dateDisplay').textContent = today.toLocaleDateString('en-US', options);
        if (currentMode === 'daily') {
            document.getElementById('puzzleNumber').textContent = getPuzzleNumber();
        }
    }

    function createGrid() {
        const grid = document.getElementById('puzzleGrid');
        grid.innerHTML = '';
        const size = gridSize * gridSize;
        for (let i = 0; i < size; i++) {
            const tile = document.createElement('button');
            tile.className = 'tile';
            tile.onclick = () => moveTile(i);
            grid.appendChild(tile);
        }
    }

    function updateDisplay() {
        const tiles = document.querySelectorAll('.tile');
        tiles.forEach((tile, index) => {
            if (puzzle[index] === null) {
                tile.textContent = '';
                tile.className = 'tile empty';
            } else {
                tile.textContent = puzzle[index];
                tile.className = 'tile';
                if (dailyPuzzleLoaded && !completionTime && canMove(index)) {
                    tile.classList.add('moveable');
                }
            }
        });
        document.getElementById('moveCounter').textContent = moves;
    }

    function canMove(index) {
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        const emptyRow = Math.floor(emptyIndex / gridSize);
        const emptyCol = emptyIndex % gridSize;
        return (Math.abs(row - emptyRow) + Math.abs(col - emptyCol)) === 1;
    }

    function moveTile(index) {
        if (!dailyPuzzleLoaded) {
            if (currentMode === 'daily') {
                updateStatus("Load today's puzzle to start playing!");
            } else {
                updateStatus("Click START to begin!");
            }
            return;
        }
        if (completionTime && currentMode === 'daily') {
            updateStatus("You already completed today's puzzle!");
            return;
        }

        if (canMove(index)) {
            if (moves === 0 && currentMode === 'daily') startTime = Date.now();
            puzzle[emptyIndex] = puzzle[index];
            puzzle[index] = null;
            emptyIndex = index;
            moves++;

            updateDisplay();
            if (currentMode === 'daily') saveProgress();

            if (isSolved()) {
                if (currentMode === 'quickplay') {
                    endQuickPlay(true);
                } else {
                    completionTime = Date.now();
                    saveProgress(true);
                    
                    const ranking = getRanking(moves);
                    const puzzleId = `puzzle-${getPuzzleNumber()}-${Date.now()}`;
                    statsManager.recordGame(puzzleId, true, moves);
                    statsManager.recordTier(ranking.tier);
                    
                    showWinMessage();
                }
            } else {
                if (currentMode === 'daily') {
                    updateStatus("You can do it!");
                }
            }
        }
    }

    function isSolved() {
        const size = gridSize * gridSize;
        for (let i = 0; i < size - 1; i++) {
            if (puzzle[i] !== i + 1) return false;
        }
        return puzzle[size - 1] === null;
    }

    function loadDailyPuzzle() {
        if (loadProgress()) {
            const grid = document.getElementById('puzzleGrid');
            grid.className = 'puzzle-grid grid-4x4';
            createGrid();
            updateDisplay();
            return;
        }
        initPuzzle();
        gridSize = 4;
        const rng = new SeededRandom(getTodaysSeed());
        for (let i = 0; i < 1000; i++) {
            const validMoves = [];
            for (let j = 0; j < 16; j++) if (canMove(j)) validMoves.push(j);
            if (validMoves.length > 0) {
                const randomMove = validMoves[Math.floor(rng.next() * validMoves.length)];
                puzzle[emptyIndex] = puzzle[randomMove];
                puzzle[randomMove] = null;
                emptyIndex = randomMove;
            }
        }
        moves = 0;
        dailyPuzzleLoaded = true;
        const grid = document.getElementById('puzzleGrid');
        grid.className = 'puzzle-grid grid-4x4';
        createGrid();
        updateDisplay();
        saveProgress();
        updateStatus("Start solving!");
    }

    function resetPuzzle() {
        if (!dailyPuzzleLoaded) {
            updateStatus(currentMode === 'daily' ? "Load today's puzzle first!" : "Click START to begin!");
            return;
        }
        
        if (currentMode === 'quickplay') {
            if (quickPlayActive) {
                if (confirm("Reset current game? Timer will continue.")) {
                    generateQuickPlayPuzzle();
                }
            }
        } else {
            localStorage.removeItem(`puzzle_${getTodaysSeed()}`);
            loadDailyPuzzle();
        }
    }

    function updateStatus(msg) {
        document.getElementById('status').textContent = msg;
    }

    function getRanking(moves) {
        if (moves <= 80) return { tier: 'Grandmaster', emoji: '🥇', color: '#FFFFFF' };
        if (moves <= 100) return { tier: 'Master', emoji: '🥈', color: '#FFFFFF' };
        if (moves <= 130) return { tier: 'Expert', emoji: '🥉', color: '#FFFFFF' };
        if (moves <= 160) return { tier: 'Advanced', emoji: '💎', color: '#FFFFFF' };
        if (moves <= 200) return { tier: 'Skilled', emoji: '⭐', color: '#FFFFFF' };
        if (moves <= 250) return { tier: 'Intermediate', emoji: '🎯', color: '#FFFFFF' };
        if (moves <= 350) return { tier: 'Beginner', emoji: '📚', color: '#FFFFFF' };
        return { tier: 'Novice', emoji: '🌱', color: '#FFFFFF' };
    }

    function getMotivationalMessage(ranking) {
        const messages = {
            'Grandmaster': ['Incredible! You\'re a puzzle legend! 🏆', 'Masterful solving! You\'re in the top 1%! ✨'],
            'Master': ['Outstanding! Master-level performance! 🎖️', 'Excellent work! You\'re among the elite! 💫'],
            'Expert': ['Great job! Expert-level skills showing! 🎓', 'Well done! You\'re an expert puzzle solver! 🧠'],
            'Advanced': ['Nice work! Advanced solver! 💪', 'Good job! You\'re getting really good at this! 🚀'],
            'Skilled': ['Solid performance! You\'re skilled! ⭐', 'Good solving! Your skills are improving! 📈'],
            'Intermediate': ['Good work! You\'re getting the hang of it! 👍', 'Nice job! Intermediate level reached! 🎯'],
            'Beginner': ['Great job completing the puzzle! 🎉', 'Well done! Every expert was once a beginner! 🌟'],
            'Novice': ['Congratulations on finishing! 🎉', 'Great job! Practice makes perfect! 🌱']
        };
        const tierMessages = messages[ranking.tier];
        return tierMessages[Math.floor(Math.random() * tierMessages.length)];
    }

    function getNextTierGoal(moves) {
        if (moves > 350) return { target: 350, tier: 'Beginner', improvement: moves - 350 };
        if (moves > 250) return { target: 250, tier: 'Intermediate', improvement: moves - 250 };
        if (moves > 200) return { target: 200, tier: 'Skilled', improvement: moves - 200 };
        if (moves > 160) return { target: 160, tier: 'Advanced', improvement: moves - 160 };
        if (moves > 130) return { target: 130, tier: 'Expert', improvement: moves - 130 };
        if (moves > 100) return { target: 100, tier: 'Master', improvement: moves - 100 };
        if (moves > 80) return { target: 80, tier: 'Grandmaster', improvement: moves - 80 };
        return null;
    }

    function shareResult() {
        if (!completionTime) {
            updateStatus("Complete the puzzle first!");
            return;
        }
        const puzzleNum = getPuzzleNumber();
        const timeInSeconds = Math.round((completionTime - startTime) / 1000);
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = timeInSeconds % 60;
        const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : `${seconds}s`;

        const ranking = getRanking(moves);
        const shareText = `Daily 15 | Puzzle Game #${puzzleNum}
${ranking.emoji} ${ranking.tier} (${moves} moves)
Time: ${timeStr}
Try it yourself! 🧩
daily15.xyz`;

        if (navigator.share) {
            navigator.share({ title: 'Daily 15 Puzzle Game', text: shareText });
        } else {
            navigator.clipboard.writeText(shareText).then(() => {
                updateStatus("Result copied to clipboard!");
                setTimeout(() => updateStatus(`Completed in ${moves} moves!`), 2000);
            }).catch(() => alert(shareText));
        }
    }

    function showWinMessage() {
        dailyPuzzleLoaded = false;
        const timeInSeconds = Math.round((completionTime - startTime) / 1000);
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = timeInSeconds % 60;
        const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : `${seconds}s`;

        const ranking = getRanking(moves);
        const motivationalMsg = getMotivationalMessage(ranking);
        const nextGoal = getNextTierGoal(moves);

        updateStatus(`${ranking.emoji} ${ranking.tier} in ${moves} moves! 🎉`);
        document.getElementById('shareBtn').style.display = 'inline-block';

        let completionHTML = `
            <div style="color: ${ranking.color}; font-size: 28px; margin-bottom: 10px;">
                ${ranking.emoji} ${ranking.tier}
            </div>
            <div style="font-size: 18px; margin-bottom: 10px;">
                ${moves} moves • ${timeStr}
            </div>
            <div style="font-size: 16px; margin-bottom: 15px; opacity: 0.9;">
                ${motivationalMsg}
            </div>`;
        if (nextGoal) {
            completionHTML += `
                <div style="font-size: 14px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px; margin-top: 10px;">
                    🎯 Next Goal: ${nextGoal.tier} tier<br>
                    (Need ${nextGoal.improvement} fewer moves)
                </div>`;
        }

        document.getElementById('completionText').innerHTML = completionHTML;
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('winnerMessage').style.display = 'block';

        const hideMessage = () => {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('winnerMessage').style.display = 'none';
            document.getElementById('overlay').removeEventListener('click', hideMessage);
            document.getElementById('winnerMessage').removeEventListener('click', hideMessage);
        };
        setTimeout(() => {
            document.getElementById('overlay').addEventListener('click', hideMessage);
            document.getElementById('winnerMessage').addEventListener('click', hideMessage);
        }, 100);
    }

    // Stats Modal Functions
    function openStatsModal() {
        const stats = statsManager.getStats();
        const qpStats = statsManager.getQuickPlayStats();
        
        document.getElementById('statGamesPlayed').textContent = stats.gamesPlayed;
        document.getElementById('statBestPerformance').textContent = stats.bestMoves ? stats.bestMoves + ' moves' : '-';
        document.getElementById('statCurrentStreak').textContent = stats.currentStreak;
        document.getElementById('statMaxStreak').textContent = stats.maxStreak;
        document.getElementById('statTotalWins').textContent = stats.gamesWon;
        document.getElementById('statAvgMoves').textContent = stats.avgMoves || 0;
        document.getElementById('statBestMoves').textContent = stats.bestMoves || '-';
        
        // Quick Play Stats
        document.getElementById('qpGamesPlayed').textContent = qpStats.gamesPlayed;
        document.getElementById('qpGamesWon').textContent = qpStats.gamesWon;
        document.getElementById('qpBestTime').textContent = qpStats.bestTime ? qpStats.bestTime + 's' : '-';
        document.getElementById('qpAvgMoves').textContent = qpStats.avgMoves || '-';
        
        updateTierDistribution();
        updateLeaderboard();
        
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('statsModal').style.display = 'block';
    }

    function updateLeaderboard() {
        const entries = statsManager.getLeaderboard();
        const container = document.getElementById('leaderboardEntries');
        const currentUser = statsManager.getUsername();
        
        if (entries.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">Complete a Quick Play to join!</div>';
            return;
        }
        
        container.innerHTML = '';
        entries.forEach((entry, index) => {
            const div = document.createElement('div');
            div.className = 'leaderboard-entry';
            if (entry.username === currentUser) {
                div.classList.add('current-user');
            }
            
            const rankEmoji = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`;
            
            div.innerHTML = `
                <span class="leaderboard-rank">${rankEmoji}</span>
                <span class="leaderboard-name">${entry.username}</span>
                <span class="leaderboard-score">${entry.time}s</span>
            `;
            container.appendChild(div);
        });
    }

    function updateTierDistribution() {
        const tiers = statsManager.getMonthlyTiers();
        const tierOrder = ['Grandmaster', 'Master', 'Expert', 'Advanced', 'Skilled', 'Intermediate', 'Beginner', 'Novice'];
        
        const totalSolves = Object.values(tiers).reduce((sum, count) => sum + count, 0);
        const maxCount = Math.max(...Object.values(tiers), 1);
        
        const now = new Date();
        const monthName = now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        
        document.getElementById('monthName').textContent = monthName;
        document.getElementById('solveCount').textContent = totalSolves === 1 ? '1 solve' : `${totalSolves} solves`;
        
        tierOrder.forEach(tier => {
            const count = tiers[tier];
            const percentage = maxCount > 0 ? (count / maxCount) * 100 : 0;
            const barId = `bar-${tier.toLowerCase()}`;
            const countId = `count-${tier.toLowerCase()}`;
            
            const barElement = document.getElementById(barId);
            const countElement = document.getElementById(countId);
            
            if (barElement && countElement) {
                barElement.style.width = percentage + '%';
                countElement.textContent = count;
            }
        });
    }

    function closeStatsModal() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('statsModal').style.display = 'none';
    }

    function exportStats() {
        const data = statsManager.exportStats();
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `daily15-stats-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        updateStatus('Stats exported!');
    }

    function resetStats() {
        if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
            statsManager.resetStats();
            closeStatsModal();
            updateStatus('Stats reset!');
        }
    }

    // Click overlay to close stats modal
    document.getElementById('overlay').addEventListener('click', function(e) {
        if (document.getElementById('statsModal').style.display === 'block') {
            closeStatsModal();
        }
    });

    // Init
    createGrid();
    initPuzzle();
    loadDailyPuzzle();

    // Touch support
    let touchStartX = 0, touchStartY = 0;
    document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, { passive: true });
    document.addEventListener('touchend', (e) => {
        if (!dailyPuzzleLoaded || completionTime) return;
        const deltaX = e.changedTouches[0].clientX - touchStartX;
        const deltaY = e.changedTouches[0].clientY - touchStartY;
        const minSwipe = 30;
        if (Math.abs(deltaX) > minSwipe || Math.abs(deltaY) > minSwipe) {
            const emptyRow = Math.floor(emptyIndex / gridSize);
            const emptyCol = emptyIndex % gridSize;
            let targetIndex = -1;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0 && emptyCol > 0) targetIndex = emptyIndex - 1;
                else if (deltaX < 0 && emptyCol < gridSize - 1) targetIndex = emptyIndex + 1;
            } else {
                if (deltaY > 0 && emptyRow > 0) targetIndex = emptyIndex - gridSize;
                else if (deltaY < 0 && emptyRow < gridSize - 1) targetIndex = emptyIndex + gridSize;
            }
            if (targetIndex >= 0 && targetIndex < gridSize * gridSize) moveTile(targetIndex);
        }
    }, { passive: true });
  </script>
</body>
</html>
