<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daily 15 | Puzzle Game</title>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNLVGXD9M4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNLVGXD9M4');
</script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      height: 90vh;
      overflow: hidden;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      padding: 15px; color: white;
    }
    .container {
      text-align: center;
      max-width: 500px; width: 100%; height: 100vh;
      display: flex; flex-direction: column; justify-content: center;
    }
    h1 { font-size: clamp(20px, 4vw, 32px); margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .game-info {
      display: flex; justify-content: space-between; margin-bottom: 15px;
      font-size: clamp(14px, 3vw, 18px); font-weight: 600;
    }
    .puzzle-container {
      background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
      border-radius: 20px; padding: 15px; margin-bottom: 15px;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    .puzzle-grid {
      display: grid; grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr); gap: 8px;
      aspect-ratio: 1; max-width: min(350px, 70vw);
      width: 100%; margin: 0 auto;
      background: rgba(0,0,0,0.2); border-radius: 15px; padding: 15px;
    }
    .tile {
      background: linear-gradient(145deg, #ffffff, #e6e6e6);
      border: none; border-radius: 12px;
      font-size: clamp(18px, 4vw, 28px); font-weight: bold;
      color: #333; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      user-select: none; transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .tile:hover { transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0); }
    .tile.empty { background: transparent; box-shadow: none; cursor: default; pointer-events: none; }
    .tile.moveable { background: linear-gradient(145deg, #4CAF50, #45a049); color: white; }
    .controls { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
    .btn {
      background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
      border: none; border-radius: 25px; padding: 10px 20px;
      font-size: clamp(12px, 2.5vw, 16px); font-weight: 600;
      color: white; cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      min-width: 80px;
    }
    .btn.shuffle { background: linear-gradient(145deg, #4CAF50, #45a049); }
    .btn.share { background: linear-gradient(145deg, #2196F3, #1976D2); }
    .btn.tutorial { background: linear-gradient(145deg, #9C27B0, #7B1FA2); }
    .btn.stats { background: linear-gradient(145deg, #FF9800, #F57C00); }
    .winner-message {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #4CAF50, #45a049);
      color: white; padding: 25px; border-radius: 20px;
      font-size: clamp(18px, 4vw, 22px); font-weight: bold;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 1000; display: none; text-align: center;
      max-width: 90vw;
    }
    .overlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999; display: none;
    }
    
    /* Stats Modal Styles */
    .stats-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      z-index: 1001;
      display: none;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }
    .stats-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 24px;
      border-radius: 24px 24px 0 0;
      position: relative;
    }
    .stats-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      transition: all 0.2s;
    }
    .stats-close:hover {
      background: rgba(255,255,255,0.3);
      transform: rotate(90deg);
    }
    .stats-content {
      padding: 24px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: linear-gradient(145deg, #f8f9fa, #e9ecef);
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      transition: transform 0.2s;
    }
    .stat-card:hover {
      transform: translateY(-4px);
    }
    .stat-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }
    .stat-value {
      font-size: 32px;
      font-weight: bold;
      color: #333;
    }
    .stat-label {
      font-size: 13px;
      color: #666;
      margin-top: 4px;
      font-weight: 600;
    }
    .stats-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }
    .stats-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }
    .stats-btn.export {
      background: linear-gradient(145deg, #2196F3, #1976D2);
      color: white;
    }
    .stats-btn.reset {
      background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
      color: white;
    }
    .stats-note {
      text-align: center;
      font-size: 12px;
      color: #666;
      background: #fff3cd;
      padding: 12px;
      border-radius: 12px;
      margin-top: 16px;
      border: 1px solid #ffc107;
    }
    .quick-stats {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }
    .quick-stats h3 {
      color: #333;
      font-size: 16px;
      margin-bottom: 12px;
    }
    .quick-stat-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #e0e0e0;
      font-size: 14px;
    }
    .quick-stat-row:last-child {
      border-bottom: none;
    }
    .quick-stat-label {
      color: #666;
    }
    .quick-stat-value {
      color: #333;
      font-weight: bold;
    }
    
    /* Monthly Tier Distribution Styles */
    .tier-distribution {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }
    .tier-distribution h3 {
      color: #333;
      font-size: 16px;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .tier-bar {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }
    .tier-bar:last-child {
      margin-bottom: 0;
    }
    .tier-label {
      min-width: 110px;
      font-size: 13px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .tier-bar-container {
      flex: 1;
      height: 20px;
      background: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }
    .tier-bar-fill {
      height: 100%;
      transition: width 0.3s ease;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 6px;
      font-size: 11px;
      font-weight: 600;
      color: white;
    }
    .tier-count {
      min-width: 20px;
      text-align: center;
      font-size: 13px;
      font-weight: bold;
      color: #333;
    }
    .tier-grandmaster { background: linear-gradient(90deg, #FFD700, #FFA500); }
    .tier-master { background: linear-gradient(90deg, #C0C0C0, #A8A8A8); }
    .tier-expert { background: linear-gradient(90deg, #CD7F32, #B87333); }
    .tier-advanced { background: linear-gradient(90deg, #667eea, #764ba2); }
    .tier-skilled { background: linear-gradient(90deg, #4CAF50, #45a049); }
    .tier-intermediate { background: linear-gradient(90deg, #2196F3, #1976D2); }
    .tier-beginner { background: linear-gradient(90deg, #FF9800, #F57C00); }
    .tier-novice { background: linear-gradient(90deg, #9E9E9E, #757575); }
    .month-badge {
      font-size: 11px;
      padding: 2px 8px;
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      border-radius: 8px;
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      text-align: right;
      line-height: 1.3;
    }
    .month-name {
      font-size: 10px;
      opacity: 0.8;
      font-weight: normal;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🧩 Daily 15 | Puzzle Game</h1>
    <div class="game-info">
      <div>
        <div style="font-size: 14px; opacity: 0.9;">Daily Puzzle #<span id="puzzleNumber"></span></div>
        <div>Moves: <span id="moveCounter">0</span></div>
      </div>
      <div style="text-align: right;">
        <div style="font-size: 14px; opacity: 0.9;" id="dateDisplay"></div>
        <div id="status">Ready to play!</div>
      </div>
    </div>
    <div class="puzzle-container">
      <div class="puzzle-grid" id="puzzleGrid"></div>
    </div>
    <div class="controls">
      <button class="btn shuffle" onclick="loadDailyPuzzle()">Today's Puzzle</button>
      <button class="btn" onclick="resetPuzzle()">Reset</button>
      <button class="btn stats" onclick="openStatsModal()">📊 Stats</button>
      <button class="btn tutorial" onclick="window.open('./tutorial.html','_blank')">How to Play</button>
      <button class="btn share" onclick="shareResult()" id="shareBtn" style="display: none;">Share Result</button>
    </div>
  </div>

  <div class="overlay" id="overlay"></div>
  <div class="winner-message" id="winnerMessage">
    🎉 Congratulations! 🎉<br>
    <span id="completionText">You solved today's puzzle!</span><br>
    <small>Click anywhere to continue</small>
  </div>

  <!-- Stats Modal -->
  <div class="stats-modal" id="statsModal">
    <div class="stats-header">
      <button class="stats-close" onclick="closeStatsModal()">×</button>
      <h2 style="font-size: 24px; margin-bottom: 4px;">📊 Your Statistics</h2>
      <p style="font-size: 14px; opacity: 0.9;">Track your Daily15 progress</p>
    </div>
    <div class="stats-content">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-icon">📅</div>
          <div class="stat-value" id="statGamesPlayed">0</div>
          <div class="stat-label">Games Played</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">⚡</div>
          <div class="stat-value" id="statBestPerformance">-</div>
          <div class="stat-label">Best Performance</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">🔥</div>
          <div class="stat-value" id="statCurrentStreak">0</div>
          <div class="stat-label">Current Streak</div>
        </div>
        <div class="stat-card">
          <div class="stat-icon">🏆</div>
          <div class="stat-value" id="statMaxStreak">0</div>
          <div class="stat-label">Best Streak</div>
        </div>
      </div>

      <!-- Monthly Tier Distribution -->
      <div class="tier-distribution" id="tierDistribution">
        <h3>
          <span>This Month's Performance</span>
          <span class="month-badge" id="monthTotal">
            <span class="month-name" id="monthName">October 2024</span>
            <span id="solveCount">0 solves</span>
          </span>
        </h3>
        <div class="tier-bar">
          <div class="tier-label">🥇 Grandmaster</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-grandmaster" id="bar-grandmaster" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-grandmaster">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🥈 Master</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-master" id="bar-master" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-master">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🥉 Expert</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-expert" id="bar-expert" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-expert">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">💎 Advanced</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-advanced" id="bar-advanced" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-advanced">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">⭐ Skilled</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-skilled" id="bar-skilled" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-skilled">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🎯 Intermediate</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-intermediate" id="bar-intermediate" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-intermediate">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">📚 Beginner</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-beginner" id="bar-beginner" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-beginner">0</div>
        </div>
        <div class="tier-bar">
          <div class="tier-label">🌱 Novice</div>
          <div class="tier-bar-container">
            <div class="tier-bar-fill tier-novice" id="bar-novice" style="width: 0%"></div>
          </div>
          <div class="tier-count" id="count-novice">0</div>
        </div>
      </div>

      <div class="quick-stats">
        <h3>My Stats</h3>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Total Wins:</span>
          <span class="quick-stat-value" id="statTotalWins">0</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Average Moves:</span>
          <span class="quick-stat-value" id="statAvgMoves">0</span>
        </div>
        <div class="quick-stat-row">
          <span class="quick-stat-label">Best Moves:</span>
          <span class="quick-stat-value" id="statBestMoves">-</span>
        </div>
      </div>

      <div class="stats-actions">
        <button class="stats-btn export" onclick="exportStats()">💾 Backup</button>
        <button class="stats-btn reset" onclick="resetStats()">🗑️ Reset</button>
      </div>

      <div class="stats-note">
        📱 Stats are saved locally on this device
      </div>
    </div>
  </div>

  <script>
    // Stats Manager with Monthly Tracking
    class Daily15StatsManager {
      constructor() {
        this.storageKey = 'daily15_game_stats';
        this.monthlyTiersKey = 'daily15_monthly_tiers';
        this.loadStats();
        this.loadMonthlyTiers();
      }

      loadStats() {
        const stored = localStorage.getItem(this.storageKey);
        if (stored) {
          this.stats = JSON.parse(stored);
        } else {
          this.stats = {
            gamesPlayed: 0,
            gamesWon: 0,
            currentStreak: 0,
            maxStreak: 0,
            lastPlayedDate: null,
            puzzleHistory: {}
          };
        }
      }

      saveStats() {
        localStorage.setItem(this.storageKey, JSON.stringify(this.stats));
      }

      loadMonthlyTiers() {
        const stored = localStorage.getItem(this.monthlyTiersKey);
        const currentMonth = this.getCurrentMonth();
        
        if (stored) {
          const data = JSON.parse(stored);
          if (data.month === currentMonth) {
            this.monthlyTiers = data;
          } else {
            this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
          }
        } else {
          this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
        }
      }

      getCurrentMonth() {
        const now = new Date();
        return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
      }

      initializeMonthlyTiers(month) {
        return {
          month: month,
          counts: {
            'Grandmaster': 0,
            'Master': 0,
            'Expert': 0,
            'Advanced': 0,
            'Skilled': 0,
            'Intermediate': 0,
            'Beginner': 0,
            'Novice': 0
          }
        };
      }

      saveMonthlyTiers() {
        localStorage.setItem(this.monthlyTiersKey, JSON.stringify(this.monthlyTiers));
      }

      recordGame(puzzleId, won, moves) {
    const today = new Date().toISOString().split('T')[0];
    
    this.stats.gamesPlayed++;
    if (won) this.stats.gamesWon++;

    if (won) {
      // Check if this is the first win of the day
      const alreadyWonToday = Object.values(this.stats.puzzleHistory).some(
        game => game.date === today && game.won
      );
      
      if (!alreadyWonToday) {
        // Only update streak if this is the first win today
        if (this.isConsecutiveDay(this.stats.lastPlayedDate, today)) {
          this.stats.currentStreak++;
        } else if (this.stats.lastPlayedDate === today) {
          // Already played today, don't change streak
        } else {
          // Gap in days, reset to 1
          this.stats.currentStreak = 1;
        }
        this.stats.maxStreak = Math.max(this.stats.maxStreak, this.stats.currentStreak);
        this.stats.lastPlayedDate = today;
      }
    } else {
      this.stats.currentStreak = 0;
      this.stats.lastPlayedDate = today;
    }

    this.stats.puzzleHistory[puzzleId] = {
      date: today,
      won: won,
      moves: moves,
      timestamp: Date.now()
    };

    this.saveStats();
}

      recordTier(tier) {
        const currentMonth = this.getCurrentMonth();
        if (this.monthlyTiers.month !== currentMonth) {
          this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
        }
        this.monthlyTiers.counts[tier]++;
        this.saveMonthlyTiers();
      }

      getMonthlyTiers() {
        const currentMonth = this.getCurrentMonth();
        if (this.monthlyTiers.month !== currentMonth) {
          this.monthlyTiers = this.initializeMonthlyTiers(currentMonth);
          this.saveMonthlyTiers();
        }
        return this.monthlyTiers.counts;
      }

      isConsecutiveDay(lastDate, currentDate) {
        if (!lastDate) return false;
        const last = new Date(lastDate);
        const current = new Date(currentDate);
        const diffTime = current - last;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);
        return diffDays === 1;
      }

      getStats() {
        const winningGames = Object.values(this.stats.puzzleHistory).filter(g => g.won);
        const avgMoves = winningGames.length > 0 
          ? Math.round(winningGames.reduce((sum, g) => sum + g.moves, 0) / winningGames.length)
          : 0;
        const bestMoves = winningGames.length > 0
          ? Math.min(...winningGames.map(g => g.moves))
          : null;

        return {
          gamesPlayed: this.stats.gamesPlayed,
          gamesWon: this.stats.gamesWon,
          winRate: this.stats.gamesPlayed > 0 
            ? Math.round((this.stats.gamesWon / this.stats.gamesPlayed) * 100) 
            : 0,
          currentStreak: this.stats.currentStreak,
          maxStreak: this.stats.maxStreak,
          avgMoves: avgMoves,
          bestMoves: bestMoves
        };
      }

      hasPlayedPuzzle(puzzleId) {
        return this.stats.puzzleHistory.hasOwnProperty(puzzleId);
      }

      exportStats() {
        return JSON.stringify(this.stats);
      }

      resetStats() {
        localStorage.removeItem(this.storageKey);
        localStorage.removeItem(this.monthlyTiersKey);
        this.loadStats();
        this.loadMonthlyTiers();
      }
    }

    const statsManager = new Daily15StatsManager();

    // Original Game Code
    let puzzle = [];
    let emptyIndex = 15;
    let moves = 0;
    let dailyPuzzleLoaded = false;
    let startTime = null;
    let completionTime = null;

    function getTodaysSeed() {
        const today = new Date();
        return today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
    }

    function getPuzzleNumber() {
        const today = new Date();
        const epoch = new Date('2025-09-20');
        const diffTime = Math.abs(today - epoch);
        return Math.floor(diffTime / (1000 * 60 * 60 * 24)) + 1;
    }

    class SeededRandom {
        constructor(seed) {
            this.seed = seed % 2147483647;
            if (this.seed <= 0) this.seed += 2147483646;
        }
        next() {
            this.seed = this.seed * 16807 % 2147483647;
            return (this.seed - 1) / 2147483646;
        }
    }

    function loadProgress() {
        const today = getTodaysSeed();
        const saved = localStorage.getItem(`puzzle_${today}`);
        if (saved) {
            const data = JSON.parse(saved);
            puzzle = data.puzzle;
            emptyIndex = data.emptyIndex;
            moves = data.moves;
            dailyPuzzleLoaded = true;

            if (data.completed) {
                completionTime = data.completionTime;
                document.getElementById('shareBtn').style.display = 'inline-block';
                updateStatus(`Completed in ${moves} moves!`);
            } else {
                startTime = data.startTime || Date.now();
                updateStatus("Continue today's puzzle!");
            }
            return true;
        }
        return false;
    }

    function saveProgress(completed = false) {
        const today = getTodaysSeed();
        localStorage.setItem(`puzzle_${today}`, JSON.stringify({
            puzzle, emptyIndex, moves,
            startTime, completed,
            completionTime: completed ? Date.now() : null
        }));
    }

    function initPuzzle() {
        puzzle = [];
        for (let i = 1; i <= 15; i++) puzzle.push(i);
        puzzle.push(null);
        emptyIndex = 15;
        moves = 0;
        dailyPuzzleLoaded = false;
        startTime = null;
        completionTime = null;
        updateDisplay();
        updateDateDisplay();
        document.getElementById('shareBtn').style.display = 'none';
    }

    function updateDateDisplay() {
        const today = new Date();
        const options = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
        document.getElementById('dateDisplay').textContent = today.toLocaleDateString('en-US', options);
        document.getElementById('puzzleNumber').textContent = getPuzzleNumber();
    }

    function createGrid() {
        const grid = document.getElementById('puzzleGrid');
        grid.innerHTML = '';
        for (let i = 0; i < 16; i++) {
            const tile = document.createElement('button');
            tile.className = 'tile';
            tile.onclick = () => moveTile(i);
            grid.appendChild(tile);
        }
    }

    function updateDisplay() {
        const tiles = document.querySelectorAll('.tile');
        tiles.forEach((tile, index) => {
            if (puzzle[index] === null) {
                tile.textContent = '';
                tile.className = 'tile empty';
            } else {
                tile.textContent = puzzle[index];
                tile.className = 'tile';
                if (dailyPuzzleLoaded && !completionTime && canMove(index)) {
                    tile.classList.add('moveable');
                }
            }
        });
        document.getElementById('moveCounter').textContent = moves;
    }

    function canMove(index) {
        const row = Math.floor(index / 4), col = index % 4;
        const emptyRow = Math.floor(emptyIndex / 4), emptyCol = emptyIndex % 4;
        return (Math.abs(row - emptyRow) + Math.abs(col - emptyCol)) === 1;
    }

    function moveTile(index) {
        if (!dailyPuzzleLoaded) {
            updateStatus("Load today's puzzle to start playing!");
            return;
        }

        if (canMove(index)) {
            if (moves === 0) startTime = Date.now();
            puzzle[emptyIndex] = puzzle[index];
            puzzle[index] = null;
            emptyIndex = index;
            moves++;

            updateDisplay();
            saveProgress();

            if (isSolved()) {
                completionTime = Date.now();
                saveProgress(true);
                
                const ranking = getRanking(moves);
                
                // Record stats - use timestamp to ensure each attempt is unique
                const puzzleId = `puzzle-${getPuzzleNumber()}-${Date.now()}`;
                statsManager.recordGame(puzzleId, true, moves);
                statsManager.recordTier(ranking.tier);
                
                showWinMessage();
            } else {
                updateStatus("You can do it!");
            }
        }
    }

    function isSolved() {
        for (let i = 0; i < 15; i++) if (puzzle[i] !== i + 1) return false;
        return puzzle[15] === null;
    }

    function loadDailyPuzzle() {
        if (loadProgress()) {
            updateDisplay();
            return;
        }
        initPuzzle();
        const rng = new SeededRandom(getTodaysSeed());
        for (let i = 0; i < 1000; i++) {
            const validMoves = [];
            for (let j = 0; j < 16; j++) if (canMove(j)) validMoves.push(j);
            if (validMoves.length > 0) {
                const randomMove = validMoves[Math.floor(rng.next() * validMoves.length)];
                puzzle[emptyIndex] = puzzle[randomMove];
                puzzle[randomMove] = null;
                emptyIndex = randomMove;
            }
        }
        moves = 0;
        dailyPuzzleLoaded = true;
        updateDisplay();
        saveProgress();
        updateStatus("Start solving!");
    }

    function resetPuzzle() {
        if (!dailyPuzzleLoaded) {
            updateStatus("Load today's puzzle first!");
            return;
        }
        localStorage.removeItem(`puzzle_${getTodaysSeed()}`);
        loadDailyPuzzle();
    }

    function updateStatus(msg) {
        document.getElementById('status').textContent = msg;
    }

    function getRanking(moves) {
        if (moves <= 80) return { tier: 'Grandmaster', emoji: '🥇', color: '#FFFFFF' };
        if (moves <= 100) return { tier: 'Master', emoji: '🥈', color: '#FFFFFF' };
        if (moves <= 130) return { tier: 'Expert', emoji: '🥉', color: '#FFFFFF' };
        if (moves <= 160) return { tier: 'Advanced', emoji: '💎', color: '#FFFFFF' };
        if (moves <= 200) return { tier: 'Skilled', emoji: '⭐', color: '#FFFFFF' };
        if (moves <= 250) return { tier: 'Intermediate', emoji: '🎯', color: '#FFFFFF' };
        if (moves <= 350) return { tier: 'Beginner', emoji: '📚', color: '#FFFFFF' };
        return { tier: 'Novice', emoji: '🌱', color: '#FFFFFF' };
    }

    function getMotivationalMessage(ranking) {
        const messages = {
            'Grandmaster': ['Incredible! You\'re a puzzle legend! 🏆', 'Masterful solving! You\'re in the top 1%! ✨'],
            'Master': ['Outstanding! Master-level performance! 🎖️', 'Excellent work! You\'re among the elite! 💫'],
            'Expert': ['Great job! Expert-level skills showing! 🎓', 'Well done! You\'re an expert puzzle solver! 🧠'],
            'Advanced': ['Nice work! Advanced solver! 💪', 'Good job! You\'re getting really good at this! 🚀'],
            'Skilled': ['Solid performance! You\'re skilled! ⭐', 'Good solving! Your skills are improving! 📈'],
            'Intermediate': ['Good work! You\'re getting the hang of it! 👍', 'Nice job! Intermediate level reached! 🎯'],
            'Beginner': ['Great job completing the puzzle! 🎉', 'Well done! Every expert was once a beginner! 🌟'],
            'Novice': ['Congratulations on finishing! 🎉', 'Great job! Practice makes perfect! 🌱']
        };
        const tierMessages = messages[ranking.tier];
        return tierMessages[Math.floor(Math.random() * tierMessages.length)];
    }

    function getNextTierGoal(moves) {
        if (moves > 350) return { target: 350, tier: 'Beginner', improvement: moves - 350 };
        if (moves > 250) return { target: 250, tier: 'Intermediate', improvement: moves - 250 };
        if (moves > 200) return { target: 200, tier: 'Skilled', improvement: moves - 200 };
        if (moves > 160) return { target: 160, tier: 'Advanced', improvement: moves - 160 };
        if (moves > 130) return { target: 130, tier: 'Expert', improvement: moves - 130 };
        if (moves > 100) return { target: 100, tier: 'Master', improvement: moves - 100 };
        if (moves > 80) return { target: 80, tier: 'Grandmaster', improvement: moves - 80 };
        return null;
    }

    function shareResult() {
        if (!completionTime) {
            updateStatus("Complete the puzzle first!");
            return;
        }
        const puzzleNum = getPuzzleNumber();
        const timeInSeconds = Math.round((completionTime - startTime) / 1000);
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = timeInSeconds % 60;
        const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : `${seconds}s`;

        const ranking = getRanking(moves);
        const shareText = `Daily 15 | Puzzle Game #${puzzleNum}
${ranking.emoji} ${ranking.tier} (${moves} moves)
Time: ${timeStr}
Try it yourself! 🧩
daily15.xyz`;

        if (navigator.share) {
            navigator.share({ title: 'Daily 15 Puzzle Game', text: shareText });
        } else {
            navigator.clipboard.writeText(shareText).then(() => {
                updateStatus("Result copied to clipboard!");
                setTimeout(() => updateStatus(`Completed in ${moves} moves!`), 2000);
            }).catch(() => alert(shareText));
        }
    }

    function showWinMessage() {
        dailyPuzzleLoaded = false;
        const timeInSeconds = Math.round((completionTime - startTime) / 1000);
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = timeInSeconds % 60;
        const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : `${seconds}s`;

        const ranking = getRanking(moves);
        const motivationalMsg = getMotivationalMessage(ranking);
        const nextGoal = getNextTierGoal(moves);

        updateStatus(`${ranking.emoji} ${ranking.tier} in ${moves} moves! 🎉`);
        document.getElementById('shareBtn').style.display = 'inline-block';

        let completionHTML = `
            <div style="color: ${ranking.color}; font-size: 28px; margin-bottom: 10px;">
                ${ranking.emoji} ${ranking.tier}
            </div>
            <div style="font-size: 18px; margin-bottom: 10px;">
                ${moves} moves • ${timeStr}
            </div>
            <div style="font-size: 16px; margin-bottom: 15px; opacity: 0.9;">
                ${motivationalMsg}
            </div>`;
        if (nextGoal) {
            completionHTML += `
                <div style="font-size: 14px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px; margin-top: 10px;">
                    🎯 Next Goal: ${nextGoal.tier} tier<br>
                    (Need ${nextGoal.improvement} fewer moves)
                </div>`;
        }

        document.getElementById('completionText').innerHTML = completionHTML;
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('winnerMessage').style.display = 'block';

        const hideMessage = () => {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('winnerMessage').style.display = 'none';
            document.getElementById('overlay').removeEventListener('click', hideMessage);
            document.getElementById('winnerMessage').removeEventListener('click', hideMessage);
        };
        setTimeout(() => {
            document.getElementById('overlay').addEventListener('click', hideMessage);
            document.getElementById('winnerMessage').addEventListener('click', hideMessage);
        }, 100);
    }

    // Stats Modal Functions
    function openStatsModal() {
        const stats = statsManager.getStats();
        
        document.getElementById('statGamesPlayed').textContent = stats.gamesPlayed;
        document.getElementById('statBestPerformance').textContent = stats.bestMoves ? stats.bestMoves + ' moves' : '-';
        document.getElementById('statCurrentStreak').textContent = stats.currentStreak;
        document.getElementById('statMaxStreak').textContent = stats.maxStreak;
        document.getElementById('statTotalWins').textContent = stats.gamesWon;
        document.getElementById('statAvgMoves').textContent = stats.avgMoves || 0;
        document.getElementById('statBestMoves').textContent = stats.bestMoves || '-';
        
        updateTierDistribution();
        
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('statsModal').style.display = 'block';
    }

    function updateTierDistribution() {
        const tiers = statsManager.getMonthlyTiers();
        const tierOrder = ['Grandmaster', 'Master', 'Expert', 'Advanced', 'Skilled', 'Intermediate', 'Beginner', 'Novice'];
        
        const totalSolves = Object.values(tiers).reduce((sum, count) => sum + count, 0);
        const maxCount = Math.max(...Object.values(tiers), 1);
        
        // Format month name
        const now = new Date();
        const monthName = now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        
        document.getElementById('monthName').textContent = monthName;
        document.getElementById('solveCount').textContent = totalSolves === 1 ? '1 solve' : `${totalSolves} solves`;
        
        tierOrder.forEach(tier => {
            const count = tiers[tier];
            const percentage = maxCount > 0 ? (count / maxCount) * 100 : 0;
            const barId = `bar-${tier.toLowerCase()}`;
            const countId = `count-${tier.toLowerCase()}`;
            
            const barElement = document.getElementById(barId);
            const countElement = document.getElementById(countId);
            
            if (barElement && countElement) {
                barElement.style.width = percentage + '%';
                countElement.textContent = count;
            }
        });
    }

    function closeStatsModal() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('statsModal').style.display = 'none';
    }

    function exportStats() {
        const data = statsManager.exportStats();
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `daily15-stats-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        updateStatus('Stats exported!');
    }

    function resetStats() {
        if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
            statsManager.resetStats();
            closeStatsModal();
            updateStatus('Stats reset!');
        }
    }

    // Click overlay to close stats modal
    document.getElementById('overlay').addEventListener('click', function(e) {
        if (document.getElementById('statsModal').style.display === 'block') {
            closeStatsModal();
        }
    });

    // Init
    createGrid();
    initPuzzle();
    loadDailyPuzzle();

    // Touch support
    let touchStartX = 0, touchStartY = 0;
    document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, { passive: true });
    document.addEventListener('touchend', (e) => {
        if (!dailyPuzzleLoaded || completionTime) return;
        const deltaX = e.changedTouches[0].clientX - touchStartX;
        const deltaY = e.changedTouches[0].clientY - touchStartY;
        const minSwipe = 30;
        if (Math.abs(deltaX) > minSwipe || Math.abs(deltaY) > minSwipe) {
            const emptyRow = Math.floor(emptyIndex / 4), emptyCol = emptyIndex % 4;
            let targetIndex = -1;
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0 && emptyCol > 0) targetIndex = emptyIndex - 1;
                else if (deltaX < 0 && emptyCol < 3) targetIndex = emptyIndex + 1;
            } else {
                if (deltaY > 0 && emptyRow > 0) targetIndex = emptyIndex - 4;
                else if (deltaY < 0 && emptyRow < 3) targetIndex = emptyIndex + 4;
            }
            if (targetIndex >= 0 && targetIndex < 16) moveTile(targetIndex);
        }
    }, { passive: true });
  </script>
</body>
</html>
